\chapter{Реализация тестов по методикам проектирования} \label{ch5}

В данной главе описывается практическая реализация тестовых случаев, разработанных в главе~\ref{ch3}, с использованием инструментов, рассмотренных в главе~\ref{ch4}.
Полные листинги исходного кода тестов приведены в приложении~\ref{appendix-tests}.

\section{Реализация тестов Equivalence Partitioning} \label{ch5:ep}

В таблице~\ref{tab:ep_impl_mapping} представлено соответствие контрольных примеров из главы~\ref{ch3} их программной реализации.

\begin{table}[htbp]
    \centering
    \caption{Соответствие контрольных примеров EP методам тестов}
    \label{tab:ep_impl_mapping}
    \begin{tabular}{|c|c|l|}
        \hline
        \textbf{TC ID} & \textbf{Класс EP} & \textbf{Метод теста} \\
        \hline
        TC-EP-01 & EP1 (пустой граф) & \hyperref[lst:ep01]{\texttt{testEmptyGraph\_EP01()}} \\
        \hline
        TC-EP-02 & EP2 (DAG) & \hyperref[lst:ep02]{\texttt{testAcyclicGraph\_EP02()}} \\
        \hline
        TC-EP-03 & EP3 (цикл) & \hyperref[lst:ep03]{\texttt{testCyclicGraph\_EP03()}} \\
        \hline
        TC-EP-04 & EP4 (невалидный формат) & \hyperref[lst:ep04]{\texttt{testInvalidFormat\_EP04()}} \\
        \hline
    \end{tabular}
\end{table}

\textbf{Тестирование валидного класса EP1: Пустой граф}

Тест \texttt{testEmptyGraph\_EP01()} проверяет корректную обработку пустого графа --- граничного случая валидного класса EP1.
Тест следует паттерну AAA (Arrange-Act-Assert), в терминологии BDD обозначаемому как Given-When-Then.

На листинге в приложении~\ref{lst:ep01} демонстрируется использование нескольких методов проверки:
\begin{itemize}
    \item \texttt{assertTrue()} --- проверка булева условия пустоты графа;
    \item \texttt{assertEquals()} --- проверка равенства количества вершин и рёбер нулю;
    \item \texttt{assertThat()} с матчерами Hamcrest --- более выразительная проверка пустоты коллекции.
\end{itemize}

Комбинирование стандартных assertions JUnit~5 и матчеров Hamcrest позволяет создавать читаемые и информативные тесты.
При падении теста сообщение об ошибке будет содержать описание на русском языке, переданное в качестве параметра.

\textbf{Тестирование валидного класса EP2: Ациклический граф}

Тест \texttt{testAcyclicGraph\_EP02()} проверяет обработку ациклического графа (DAG) --- основного валидного класса.
Используется конструктор графа, принимающий списки вершин и рёбер.

Ключевые особенности реализации:
\begin{itemize}
    \item Использование \texttt{assertAll()} для группировки связанных проверок --- при падении одной из них тест продолжит выполнение остальных;
    \item Применение матчеров \texttt{hasSize()}, \texttt{containsInAnyOrder()}, \texttt{hasItem()} для проверки коллекций;
    \item Проверка структуры графа через метод \texttt{getNeighbors()}.
\end{itemize}

\textbf{Тестирование невалидного класса EP3: Граф с циклом}

Невалидный класс EP3 представляет графы, содержащие циклы.
Такие графы не допускают топологической сортировки, поэтому тест \texttt{testCyclicGraph\_EP03()} проверяет, что система корректно создаёт граф с циклом (сам граф валиден как структура данных), но при сортировке должна быть обнаружена ошибка.

На данном этапе проверяется только корректность создания структуры графа с циклом.
Тестирование обнаружения цикла при сортировке выполняется в тестах алгоритмов.

\textbf{Тестирование невалидного класса EP4: Некорректный формат}

Тест \texttt{testInvalidFormat\_EP04()} проверяет обработку невалидных входных данных. Используется \texttt{assertThrows()} для проверки выброса исключения \texttt{IllegalArgumentException} при попытке создать граф с некорректным форматом рёбер (ребро с одной вершиной вместо двух).

\section{Реализация тестов Boundary Value Analysis} \label{ch5:bva}

В таблице~\ref{tab:bva_impl_mapping} представлено соответствие контрольных примеров.

\begin{table}[htbp]
    \centering
    \caption{Соответствие контрольных примеров BVA методам тестов}
    \label{tab:bva_impl_mapping}
    \begin{tabular}{|c|l|l|}
        \hline
        \textbf{TC ID} & \textbf{Граничное значение} & \textbf{Метод теста} \\
        \hline
        TC-BVA-01 & 0 вершин & \hyperref[lst:bva01]{\texttt{testZeroVertices\_BVA01()}} \\
        \hline
        TC-BVA-02 & 1 вершина & \hyperref[lst:bva01]{\texttt{testOneVertex\_BVA02()}} \\
        \hline
        TC-BVA-03 & 2 вершины, 0 рёбер & \hyperref[lst:bva03]{\texttt{testTwoVerticesNoEdges\_BVA03()}} \\
        \hline
        TC-BVA-04 & 2 вершины, 1 ребро & \hyperref[lst:bva03]{\texttt{testTwoVerticesOneEdge\_BVA04()}} \\
        \hline
        TC-BVA-05 & Полный DAG & \hyperref[lst:bva05]{\texttt{testCompleteDAG\_BVA05()}} \\
        \hline
        TC-BVA-06 & Большой граф & \hyperref[lst:bva06]{\texttt{testLargeGraph\_BVA06()}} \\
        \hline
    \end{tabular}
\end{table}

\textbf{Граница минимального размера: 0 и 1 вершина}

Тесты TC-BVA-01 и TC-BVA-02 проверяют минимальные допустимые размеры графа.

Тест \texttt{testZeroVertices\_BVA01()} использует \texttt{assumeTrue()} для предварительной проверки условия. Assumptions позволяют пропустить тест, если предусловие не выполнено, что отличается от падения теста при использовании assertions.

Тест \texttt{testOneVertex\_BVA02()} проверяет граф с одной вершиной без рёбер. Матчер \texttt{is(empty())} от Hamcrest обеспечивает читаемую проверку отсутствия соседей у единственной вершины.

\textbf{Граница связности: 2 вершины}

Тесты TC-BVA-03 и TC-BVA-04 исследуют границу между несвязным и связным графом из двух вершин.

Тест \texttt{testTwoVerticesNoEdges\_BVA03()} проверяет несвязный граф. Использование \texttt{containsInAnyOrder()} допускает любой порядок вершин в результате, что соответствует спецификации топологической сортировки для несвязных графов.

Тест \texttt{testTwoVerticesOneEdge\_BVA04()} применяет \texttt{assertAll()} для комплексной проверки минимального связного графа. Матчер \texttt{contains()} требует точного соответствия порядка элементов.

\textbf{Параметризованный тест для полных DAG}

Тест TC-BVA-05 реализован как параметризованный тест с использованием аннотации \texttt{@CsvSource}.
Это позволяет проверить полные ациклические графы различных размеров с помощью одного метода.

Формула для количества рёбер в полном DAG: $E = \frac{n(n-1)}{2}$, где $n$ --- количество вершин.
Параметризованный тест проверяет это соотношение для графов с 3 и 4 вершинами.

\textbf{Тестирование большого графа}

Тест TC-BVA-06 проверяет производительность и корректность обработки графа с большим количеством вершин.
Используется аннотация \texttt{@Timeout(5)} для ограничения времени выполнения теста пятью секундами.

Динамическое создание линейного графа с 1000 вершинами позволяет проверить:
\begin{itemize}
    \item Отсутствие ошибок переполнения стека при рекурсивном DFS;
    \item Приемлемое время выполнения алгоритмов;
    \item Корректность результата для больших входных данных.
\end{itemize}

\section{Реализация тестов Decision Table Testing} \label{ch5:dt}

Реализация тестов основана на правилах из таблицы~\ref{tab:dt_rules} главы~\ref{ch3}.
В таблице~\ref{tab:dt_impl_mapping} представлено соответствие правил методам тестов.

\begin{table}[htbp]
    \centering
    \caption{Соответствие правил Decision Table методам тестов}
    \label{tab:dt_impl_mapping}
    \begin{tabular}{|c|p{5cm}|l|}
        \hline
        \textbf{TC ID} & \textbf{Правило} & \textbf{Метод теста} \\
        \hline
        TC-DT-01 & R1: Пустой граф & \hyperref[lst:dt01]{\texttt{testDT\_R1\_EmptyGraph()}} \\
        \hline
        TC-DT-02 & R2: DAG без цикла & \hyperref[lst:dt01]{\texttt{testDT\_R2\_ValidDAG()}} \\
        \hline
        TC-DT-03 & R3: Цикл обнаружен & \hyperref[lst:dt01]{\texttt{testDT\_R3\_CycleDetected()}} \\
        \hline
        TC-DT-04 & R4: Файл не найден & \hyperref[lst:dt04]{\texttt{testDT\_R4\_FileNotFound()}} \\
        \hline
        TC-DT-05 & R5: Невалидный JSON & \hyperref[lst:dt04]{\texttt{testDT\_R5\_InvalidJSON()}} \\
        \hline
        TC-DT-06 & R6: Алгоритм не выбран & \hyperref[lst:dt04]{\texttt{testDT\_R6\_NoAlgorithm()}} \\
        \hline
    \end{tabular}
\end{table}

\textbf{Вложенные тестовые классы для Decision Table}

Для логической группировки тестов Decision Table используется аннотация \texttt{@Nested}.
Вложенный класс \texttt{DecisionTableTests} содержит все тесты, соответствующие правилам таблицы решений.

Каждый тест проверяет определённую комбинацию условий C1--C5 и ожидаемые действия системы.
Аннотация \texttt{@DisplayName} содержит идентификатор правила для удобной трассировки.

\textbf{Тестирование правил обработки ошибок}

Тесты TC-DT-04 и TC-DT-05 проверяют обработку ошибок ввода-вывода.
Для тестирования работы с файловой системой используется класс \texttt{JsonGraphHandler}, который инкапсулирует логику чтения и записи JSON-файлов.

Тест \texttt{testDT\_R4\_FileNotFound()} проверяет выброс \texttt{FileNotFoundException} при попытке загрузить несуществующий файл.

Тест \texttt{testDT\_R5\_InvalidJSON()} использует временный файл с невалидным JSON-содержимым для проверки обработки ошибок парсинга.

\section{Реализация тестов Branch Testing} \label{ch5:branch}

Тестирование ветвей (Branch Testing) относится к методам структурного тестирования и требует знания внутренней структуры кода.
В таблице~\ref{tab:branch_impl_mapping} представлено соответствие ветвей методам тестов.

\begin{table}[htbp]
    \centering
    \caption{Соответствие ветвей кода методам тестов}
    \label{tab:branch_impl_mapping}
    \begin{tabular}{|c|p{4.5cm}|l|}
        \hline
        \textbf{TC ID} & \textbf{Покрываемая ветвь} & \textbf{Метод теста} \\
        \hline
        TC-BR-01 & \texttt{isEmpty() → true} & \hyperref[lst:br01]{\texttt{testBranch\_IsEmpty\_True()}} \\
        \hline
        TC-BR-02 & \texttt{isEmpty() → false}, одна вершина & \hyperref[lst:br01]{\texttt{testBranch\_IsEmpty\_False\_SingleVertex()}} \\
        \hline
        TC-BR-03 & Обнаружение цикла (GRAY) & \hyperref[lst:br01]{\texttt{testBranch\_CycleDetection()}} \\
        \hline
        TC-BR-04 & Пропуск посещённой (BLACK) & \hyperref[lst:br01]{\texttt{testBranch\_AlreadyVisited()}} \\
        \hline
        TC-BR-05 & Полный обход (process) & \hyperref[lst:br01]{\texttt{testBranch\_FullTraversal()}} \\
        \hline
    \end{tabular}
\end{table}

\textbf{Организация тестов ветвей}

Тесты Branch Testing организованы во вложенном классе \texttt{BranchTests}.
Каждый тест нацелен на покрытие конкретной ветви алгоритма DFS топологической сортировки.

\textbf{Тестирование ветви обнаружения цикла}

Тест TC-BR-03 проверяет ветвь, отвечающую за обнаружение цикла.
В алгоритме DFS вершина находится в состоянии GRAY во время обработки её потомков.
Повторное посещение GRAY-вершины означает наличие цикла.

Граф A→B→C→A содержит цикл, что позволяет проверить корректную работу механизма обнаружения.

\textbf{Тестирование ветви пропуска посещённых вершин}

Тест TC-BR-04 использует граф с алмазной структурой (diamond structure), где вершина D достижима из A двумя путями: через B и через C.

Такая структура гарантирует, что при обходе графа вершина D будет посещена повторно, что должно привести к срабатыванию ветви пропуска уже посещённых вершин (состояние BLACK).

Метод \texttt{calculateInDegrees()} используется для верификации структуры графа --- входящая степень вершины D должна равняться 2.

\section{Интеграционные тесты с использованием Mockito} \label{ch5:integration}

Для тестирования взаимодействия компонентов и изоляции тестируемых классов применяется фреймворк Mockito~\cite{parkhomenko-lectures}.
В таблице~\ref{tab:mockito_usage} представлены основные сценарии использования моков в проекте.

\begin{table}[htbp]
    \centering
    \caption{Сценарии использования Mockito в тестах}
    \label{tab:mockito_usage}
    \begin{tabular}{|l|p{7cm}|}
        \hline
        \textbf{Сценарий} & \textbf{Цель} \\
        \hline
        \hyperref[lst:mockito]{Mock Graph} & Изоляция тестов алгоритмов от реализации графа \\
        \hline
        \hyperref[lst:spy]{Spy Algorithm} & Отслеживание вызовов методов реального объекта \\
        \hline
        \hyperref[lst:mockito]{ArgumentCaptor} & Захват и проверка аргументов методов \\
        \hline
        \hyperref[lst:mockito]{verify()} "& Проверка взаимодействия между компонентами \\
        \hline
    \end{tabular}
\end{table}

\textbf{Использование Mock-объектов}

Для создания mock-объектов используется расширение \texttt{MockitoExtension} и аннотация \texttt{@Mock}.
Mock-объект графа позволяет тестировать алгоритмы сортировки независимо от реализации класса \texttt{Graph}.

Методы \texttt{when(...).thenReturn(...)} настраивают поведение мока, а \texttt{verify(...)} проверяют, что методы были вызваны с ожидаемыми аргументами.

\textbf{Использование Spy-объектов}

Аннотация \texttt{@Spy} создаёт spy-объект, который оборачивает реальный объект и позволяет отслеживать вызовы его методов, сохраняя при этом реальную реализацию.

Spy-объекты используются для проверки того, что алгоритм сортировки корректно взаимодействует с графом: вызывает \texttt{getVertices()}, \texttt{getNeighbors()} и другие методы в правильном порядке.

\textbf{Сравнение алгоритмов}

Интеграционные тесты включают сравнение результатов работы алгоритмов DFS и Кана.
Параметризованный тест \texttt{compareAlgorithms\_VariousGraphs()} использует \texttt{@MethodSource} для передачи различных графов и проверяет,
что оба алгоритма дают корректные результаты.

Тест \texttt{compareAlgorithms\_Performance()} измеряет время выполнения обоих алгоритмов на большом графе, обеспечивая проверку производительности.

\section{Анализ покрытия кода} \label{ch5:coverage}

Для измерения покрытия кода тестами используется плагин JaCoCo. Результаты анализа покрытия позволяют оценить полноту тестирования и выявить непокрытые участки кода.

\textbf{Метрики покрытия}

В таблице~\ref{tab:coverage_metrics} представлены результаты измерения покрытия для основных классов проекта.

\begin{table}[htbp]
    \centering
    \caption{Метрики покрытия кода тестами}
    \label{tab:coverage_metrics}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Класс} & \textbf{Line Coverage} & \textbf{Branch Coverage} & \textbf{Method Coverage} \\
        \hline
        Graph & 100\% & 96\% & 100\% \\
        \hline
        DfsTopologicalSort & 100\% & 100\% & 100\% \\
        \hline
        KahnTopologicalSort & 100\% & 95\% & 100\% \\
        \hline
        SortValidator & 96\% & 92\% & 100\% \\
        \hline
        JsonGraphHandler & 89\% & 75\% & 100\% \\
        \hline
        ComparisonResult & 100\% & 92\% & 100\% \\
        \hline
        SortResult & 100\% & 92\% & 100\% \\
        \hline
        Application & 82\% & 85\% & 85\% \\
        \hline
        \textbf{Общее} & \textbf{92\%} & \textbf{89\%} & \textbf{97\%} \\
        \hline
    \end{tabular}
\end{table}

\section{Выводы} \label{ch5:conclusion}

В данной главе представлена практическая реализация тестовых случаев, спроектированных в главе~\ref{ch3}, с использованием фреймворка JUnit~5 и библиотек Hamcrest и Mockito.

Тесты Equivalence Partitioning реализованы с использованием стандартных assertions JUnit~5 и матчеров Hamcrest, что обеспечивает читаемость и информативность сообщений об ошибках.

Тесты Boundary Value Analysis включают параметризованные тесты с аннотациями \texttt{@CsvSource} и \texttt{@MethodSource}, позволяющие проверить множество граничных значений с помощью компактного кода.

Тесты Decision Table организованы во вложенных классах с использованием \texttt{@Nested}, что обеспечивает логическую группировку и читаемую структуру отчётов о тестировании.

Тесты Branch Testing нацелены на покрытие конкретных ветвей алгоритма DFS и используют специально подобранные входные данные для активации каждой ветви.

Интеграционные тесты с Mockito позволяют изолировать тестируемые компоненты и проверять их взаимодействие.

Общее покрытие кода составило 92\% по строкам, 97\% по методам и 89\% по ветвям.

Полные листинги исходного кода тестов приведены в приложении~\ref{appendix-tests}.

\clearpage