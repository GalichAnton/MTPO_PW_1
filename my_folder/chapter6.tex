\chapter{Описание реализации программы} \label{ch6}

В данной главе представлено краткое описание реализации основного кода программы топологической сортировки графов.
Программа реализована на языке Java с использованием объектно-ориентированного подхода и паттернов проектирования ~\cite{eckel-java-ru}.


Полные листинги исходного кода приведены в приложении~\ref{appendix-code}.

\section{Архитектура приложения} \label{ch6:architecture}

Приложение разработано с соблюдением принципов разделения ответственности (Separation of Concerns) и организовано в четыре логических пакета:
\begin{itemize}
    \item \texttt{model} --- классы модели данных (\texttt{Graph}, \texttt{SortResult}, \texttt{ComparisonResult});
    \item \texttt{algorithm} --- реализации алгоритмов сортировки (\texttt{DfsTopologicalSort}, \texttt{KahnTopologicalSort});
    \item \texttt{io} --- подсистема ввода-вывода (\texttt{JsonGraphHandler});
    \item \texttt{util} --- вспомогательные утилиты (\texttt{SortValidator}).
\end{itemize}

На рисунке~\ref{fig:class_diagram} представлена упрощённая диаграмма классов приложения.

\begin{figure}[H]
    \centering
    \begin{tcolorbox}[
        colback=gray!5,
        colframe=gray!75,
        title={Структура пакетов приложения},
        fontupper=\ttfamily\small
    ]
        \begin{verbatim}
topological-sort/
+-- model/
|   +-- Graph.java              # Представление графа
|   +-- SortResult.java         # Результат сортировки
|   +-- ComparisonResult.java   # Результат сравнения
+-- algorithm/
|   +-- TopologicalSortAlgorithm.java  # Интерфейс
|   +-- DfsTopologicalSort.java        # DFS-реализация
|   +-- KahnTopologicalSort.java       # Алгоритм Кана
+-- io/
|   +-- JsonGraphHandler.java   # Работа с JSON
+-- util/
|   +-- SortValidator.java      # Валидация результатов
+-- Application.java            # Точка входа
        \end{verbatim}
    \end{tcolorbox}
    \caption{Структура пакетов приложения}
    \label{fig:class_diagram}
\end{figure}

В таблице~\ref{tab:class_responsibilities} представлены классы приложения и их ответственности.

\begin{table}[htbp]
    \centering
    \caption{Классы приложения и их ответственности}
    \label{tab:class_responsibilities}
    \small
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Класс} & \textbf{Ответственность} \\
        \hline
        \texttt{Graph} & Хранение структуры графа, операции над вершинами и рёбрами \\
        \hline
        \texttt{SortResult} & Инкапсуляция результата сортировки (успех/ошибка) \\
        \hline
        \texttt{ComparisonResult} & Хранение результатов сравнения алгоритмов \\
        \hline
        \texttt{TopologicalSortAlgorithm} & Контракт для алгоритмов сортировки \\
        \hline
        \texttt{DfsTopologicalSort} & Реализация алгоритма на основе DFS \\
        \hline
        \texttt{KahnTopologicalSort} & Реализация алгоритма Кана (BFS) \\
        \hline
        \texttt{JsonGraphHandler} & Сериализация/десериализация JSON \\
        \hline
        \texttt{SortValidator} & Проверка корректности топологического порядка \\
        \hline
        \texttt{Application} & Консольный интерфейс пользователя \\
        \hline
    \end{tabular}
\end{table}

\section{Модель данных} \label{ch6:model}

\subsection*{Класс Graph}

Класс \texttt{Graph} представляет ориентированный граф с использованием списка смежности.
Выбор данной структуры данных обусловлен эффективностью операций обхода, критичных для алгоритмов топологической сортировки.

Основные характеристики реализации:
\begin{itemize}
    \item Использование \texttt{LinkedHashSet} для хранения вершин обеспечивает сохранение порядка добавления;
    \item Список смежности реализован через \texttt{Map<String, List<String>>};
    \item Поддержка произвольных строковых идентификаторов вершин;
    \item Валидация входных данных при добавлении вершин и рёбер.
\end{itemize}

Временная сложность основных операций представлена в таблице~\ref{tab:graph_complexity}.

\begin{table}[htbp]
    \centering
    \caption{Временная сложность операций класса Graph}
    \label{tab:graph_complexity}
    \begin{tabular}{|l|c|l|}
        \hline
        \textbf{Операция} & \textbf{Сложность} & \textbf{Описание} \\
        \hline
        \texttt{addVertex} & $O(1)$ & Добавление вершины \\
        \hline
        \texttt{addEdge} & $O(1)$ & Добавление ребра \\
        \hline
        \texttt{getNeighbors} & $O(1)$ & Получение соседей \\
        \hline
        \texttt{containsVertex} & $O(1)$ & Проверка наличия вершины \\
        \hline
        \texttt{calculateInDegrees} & $O(V + E)$ & Вычисление входящих степеней \\
        \hline
    \end{tabular}
\end{table}

Полный листинг класса \texttt{Graph} приведён в приложении~\ref{app:graph-code}.

\subsection*{Класс SortResult}

Класс \texttt{SortResult} использует паттерн <<неизменяемый объект>> (Immutable Object) для представления результата топологической сортировки. Применение статических фабричных методов \texttt{success()} и \texttt{failure()} обеспечивает ясность намерений при создании объектов.

Ключевые проектные решения:
\begin{itemize}
    \item Все поля объявлены как \texttt{final};
    \item Коллекции возвращаются в неизменяемом виде через \texttt{Collections.unmodifiableList()};
    \item Включены метаданные: использованный алгоритм и время выполнения.
\end{itemize}

Полный листинг класса \texttt{SortResult} приведён в приложении~\ref{app:sortresult-code}.

\subsection*{Класс ComparisonResult}

Класс \texttt{ComparisonResult} реализован с использованием паттерна <<Строитель>> (Builder), что обусловлено большим количеством полей (9 параметров). Паттерн обеспечивает читаемость кода при создании объектов и позволяет добавлять новые поля без изменения конструктора.

Класс содержит:
\begin{itemize}
    \item Результаты обоих алгоритмов (\texttt{SortResult});
    \item Метаданные графа (количество вершин и рёбер);
    \item Флаги валидности результатов;
    \item Вычисляемые метрики сравнения;
    \item Рекомендации по выбору алгоритма.
\end{itemize}

Полный листинг класса \texttt{ComparisonResult} приведён в приложении~\ref{app:comparison-code}.

\section{Алгоритмы топологической сортировки} \label{ch6:algorithms}

\subsection*{Интерфейс TopologicalSortAlgorithm}

Для обеспечения возможности подмены алгоритмов введён интерфейс \texttt{TopologicalSortAlgorithm}, определяющий контракт для всех реализаций. Интерфейс содержит два метода:
\begin{itemize}
    \item \texttt{sort(Graph)} --- выполнение топологической сортировки;
    \item \texttt{getName()} --- получение названия алгоритма.
\end{itemize}

Полный листинг интерфейса приведён в приложении~\ref{app:interface-code}.

\subsection*{DFS-алгоритм}


Класс \texttt{DfsTopologicalSort} реализует топологическую сортировку на основе поиска в глубину (Depth-First Search)\cite{bhargava-algorithms-ru}.
Алгоритм использует трёхцветную маркировку вершин для отслеживания состояния обработки.

Состояния вершин:
\begin{itemize}
    \item \texttt{WHITE} --- вершина не посещена;
    \item \texttt{GRAY} --- вершина в процессе обработки (на стеке рекурсии);
    \item \texttt{BLACK} --- обработка вершины завершена.
\end{itemize}

Обнаружение цикла происходит при попытке посетить GRAY-вершину --- это означает наличие обратного ребра и, следовательно, цикла.

Алгоритмическая сложность:
\begin{itemize}
    \item Временная: $O(V + E)$;
    \item Пространственная: $O(V)$ для хранения цветов и стека рекурсии.
\end{itemize}

Полный листинг класса \texttt{DfsTopologicalSort} приведён в приложении~\ref{app:dfs-code}.

\subsection*{Алгоритм Кана}


Класс \texttt{KahnTopologicalSort} реализует алгоритм Кана\cite{bhargava-algorithms-ru}, основанный на последовательном удалении вершин с нулевой входящей степенью.

Этапы работы алгоритма:
\begin{enumerate}
    \item Вычисление входящих степеней для всех вершин;
    \item Добавление вершин с in-degree = 0 в очередь;
    \item Извлечение вершины из очереди, добавление в результат;
    \item Уменьшение in-degree соседей на 1;
    \item Повторение пунктов 3-4 до опустошения очереди.
\end{enumerate}

Цикл обнаруживается, если после завершения работы алгоритма количество обработанных вершин меньше общего количества вершин в графе.

Алгоритмическая сложность:
\begin{itemize}
    \item Временная: $O(V + E)$;
    \item Пространственная: $O(V)$ для хранения степеней и очереди.
\end{itemize}

Полный листинг класса \texttt{KahnTopologicalSort} приведён в приложении~\ref{app:kahn-code}.

\subsection*{Сравнение алгоритмов}

В таблице~\ref{tab:algorithm_comparison} представлено сравнение реализованных алгоритмов.

\begin{table}[htbp]
    \centering
    \caption{Сравнение алгоритмов топологической сортировки}
    \label{tab:algorithm_comparison}
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Характеристика} & \textbf{DFS} & \textbf{Kahn} \\
        \hline
        Временная сложность & $O(V + E)$ & $O(V + E)$ \\
        \hline
        Пространственная сложность & $O(V)$ & $O(V)$ \\
        \hline
        Тип обхода & Рекурсивный & Итеративный \\
        \hline
        Риск переполнения стека & Да & Нет \\
        \hline
        Порядок результата & Обратный постпорядок & Прямой порядок \\
        \hline
        Детектирование цикла & Обратное ребро & Неполный результат \\
        \hline
    \end{tabular}
\end{table}


\section{Подсистема ввода-вывода} \label{ch6:io}

Класс \texttt{JsonGraphHandler} обеспечивает сериализацию и десериализацию графов и результатов в формате JSON с использованием библиотеки Jackson.

\subsection*{Формат входных данных}

Граф представляется в формате JSON со следующей структурой:

\begin{verbatim}
{
  "vertices": ["A", "B", "C", "D"],
  "edges": [
    {"from": "A", "to": "B"},
    {"from": "A", "to": "C"},
    {"from": "B", "to": "D"},
    {"from": "C", "to": "D"}
  ]
}
\end{verbatim}


\noindent
\begin{minipage}{\linewidth}
\subsection*{Формат выходных данных}

Результат сортировки сохраняется в следующем формате:
\begin{verbatim}
{
  "success": true,
  "algorithm": "DFS",
  "sorted": ["A", "B", "C", "D"],
  "execution_time_ms": 0.125
}
\end{verbatim}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\subsection*{Формат результата сравнения алгоритмов}

При сравнении двух алгоритмов результат сохраняется в расширенном формате, включающем метаданные графа, результаты каждого алгоритма и метрики сравнения:
\begin{verbatim}
{
  "graph_info": {
    "vertex_count": 4,
    "edge_count": 4
  },
  "dfs": {
    "algorithm": "DFS",
    "success": true,
    "execution_time_ms": 0.125,
    "valid": true,
    "sorted": ["A", "B", "C", "D"]
  },
  "kahn": {
    "algorithm": "Kahn",
    "success": true,
    "execution_time_ms": 0.098,
    "valid": true,
    "sorted": ["A", "C", "B", "D"]
  },
  "comparison": {
    "both_success": true,
    "both_valid": true,
    "identical_order": false,
    "faster_algorithm": "Kahn",
    "time_difference_ms": 0.027,
  }
}
\end{verbatim}
\end{minipage}



\subsection*{Обработка ошибок}

Класс определяет два типа проверяемых исключений:
\begin{itemize}
    \item \texttt{GraphLoadException} --- ошибки загрузки графа (файл не найден, некорректный JSON);
    \item \texttt{GraphSaveException} --- ошибки сохранения результата.
\end{itemize}

Полный листинг класса \texttt{JsonGraphHandler} приведён в приложении~\ref{app:json-code}.

\section{Валидация результатов} \label{ch6:validation}

Класс \texttt{SortValidator} предоставляет статические методы для проверки корректности топологической сортировки и сравнения результатов алгоритмов.

\subsection*{Проверка топологического порядка}

Метод \texttt{isValidTopologicalOrder()} проверяет, что для каждого ребра $u \rightarrow v$ вершина $u$ предшествует вершине $v$ в результате сортировки. Алгоритм проверки:
\begin{enumerate}
    \item Создание отображения: вершина $\rightarrow$ позиция в результате;
    \item Для каждого ребра $(u, v)$ проверка, что $position(u) < position(v)$;
    \item Возврат \texttt{false} при нарушении условия.
\end{enumerate}

\subsection*{Сравнение алгоритмов}

Метод \texttt{compareAlgorithms()} формирует объект \texttt{ComparisonResult}, включающий:
\begin{itemize}
    \item Валидацию результатов обоих алгоритмов;
    \item Сравнение времени выполнения;
    \item Проверку идентичности порядка;
    \item Генерацию рекомендаций.
\end{itemize}

Полный листинг класса \texttt{SortValidator} приведён в приложении~\ref{app:validator-code}.

\section{Консольное приложение} \label{ch6:app}

Класс \texttt{Application} реализует консольный интерфейс пользователя с интерактивным меню. Применение принципа инверсии зависимостей (Dependency Injection) через конструктор позволяет подменять потоки ввода-вывода для тестирования.

\subsection*{Функциональные возможности}

Приложение предоставляет следующие функции:
\begin{enumerate}
    \item Ввод графа вручную через консоль;
    \item Загрузка графа из JSON-файла;
    \item Выбор и выполнение алгоритма сортировки;
    \item Сравнение результатов обоих алгоритмов;
    \item Сохранение результатов в файл;
    \item Отображение текущего графа;
    \item Справочная информация.
\end{enumerate}

\subsection*{Структура меню}

Главное меню приложения:

\begin{verbatim}
┌────────────────────────────────────────┐
│              ГЛАВНОЕ МЕНЮ              │
├────────────────────────────────────────┤
│  1. Справка                            │
│  2. Ввести граф вручную                │
│  3. Загрузить граф из JSON-файла       │
│  4. Выполнить сортировку               │
│  5. Сравнить оба алгоритма             │
│  6. Сохранить результат в файл         │
│  7. Сохранить сравнение в файл         │
│  8. Показать текущий граф              │
│  0. Выход                              │
└────────────────────────────────────────┘
\end{verbatim}

Полный листинг класса \texttt{Application} приведён в приложении~\ref{app:application-code}.

\section{Выводы} \label{ch6:conclusion}

В данной главе представлено краткое описание реализации программы топологической сортировки графов.
Основные результаты:

\begin{enumerate}
    \item Разработана модульная архитектура с чётким разделением ответственности между компонентами.

    \item Реализованы два алгоритма топологической сортировки (DFS и Kahn) с одинаковой асимптотической сложностью $O(V + E)$.

    \item Разработана подсистема ввода-вывода для работы с JSON-форматом.

    \item Реализована система валидации результатов с возможностью сравнения алгоритмов.

    \item Создан консольный интерфейс с интерактивным меню.
\end{enumerate}

Полные листинги исходного кода приведены в приложении~\ref{appendix-code}.

\clearpage