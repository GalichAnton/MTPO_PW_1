\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}

В ходе выполнения практической работы была достигнута поставленная цель --- изучены и применены на практике принципы модульного тестирования и разработки через тестирование (TDD). Все задачи, сформулированные во введении, были выполнены.

\textbf{Результаты проектирования приложения.} Было разработано консольное Java-приложение для топологической сортировки ориентированных ациклических графов (DAG).
В приложении реализованы два алгоритма: на основе поиска в глубину (DFS) и алгоритм Кана (с использованием входящих степеней вершин).
Код разбит на четыре пакета: \texttt{model} --- классы данных (Graph, SortResult, ComparisonResult), \texttt{algorithm} --- реализации алгоритмов с общим интерфейсом TopologicalSortAlgorithm, \texttt{io} --- чтение и запись графов в формате JSON, \texttt{util} --- валидация результатов сортировки. Такая структура позволяет легко добавлять новые алгоритмы и удобно тестировать каждый компонент отдельно.

\textbf{Результаты проектирования тестов.} Для проектирования тестов были использованы четыре метода: разбиение на классы эквивалентности (Equivalence Partitioning), анализ граничных значений (Boundary Value Analysis), таблицы решений (Decision Table Testing) и тестирование ветвей (Branch Testing). На основе этих методов были определены 16 проверяемых условий, охватывающих входные данные, выходные данные и внутреннюю логику обработки. По этим условиям была составлена тестовая документация, которая затем послужила основой для написания кода тестов.

\textbf{Преимущества библиотеки JUnit~5.} В качестве основного фреймворка для тестирования был выбран JUnit~5.
Он хорошо подошёл для данной работы по нескольким причинам.
Во-первых, удобные аннотации \texttt{@ParameterizedTest}, \texttt{@CsvSource}, \texttt{@ValueSource} позволили компактно записать тесты для множества входных значений.
Во-вторых, аннотация \texttt{@Nested} помогла логически сгруппировать тесты внутри одного класса.
В-третьих, JUnit~5 хорошо работает с Maven и средами разработки, что упрощает запуск и отладку тестов.
Также важна совместимость с дополнительными библиотеками --- Hamcrest для наглядных проверок и Mockito для подмены зависимостей.

\textbf{Недостатки JUnit~5.} Из минусов можно отметить, что по сравнению с JUnit~4 у пятой версии сложнее структура: есть JUnit Platform, Jupiter, Vintage, и в начале работы приходится разбираться, какие зависимости подключать. Также JUnit~5 не имеет встроенных средств для мутационного тестирования --- для этого пришлось отдельно подключать Pitest. Для некоторых проверок (например, сравнение коллекций) стандартных assertions не хватает и нужен Hamcrest.

\textbf{Количество и качество тестов.} Всего было написано более 125 тестовых методов в 5 тестовых классах.
Для оценки качества тестов использовались следующие метрики:
\begin{itemize}
    \item покрытие строк кода (Line Coverage) --- 99\% (163 из 164 строк);
    \item мутационный скоринг (Mutation Score) --- 90\% (79 из 88 мутаций убито);
    \item сила тестов (Test Strength) --- 90\%;
\end{itemize}

Начальный mutation score составлял 82\%.
После анализа выживших мутаций были добавлены 6 дополнительных тестов, которые убили ещё 7 мутаций, и показатель вырос до 90\%.
Оставшиеся 9 выживших мутаций относятся к методам форматирования вывода (\texttt{toString}) и дублирующей валидации (\texttt{addEdge}),
то есть не затрагивают основную логику алгоритмов.
Итоговый MSI = 90\% превышает типичные промышленные пороги (60--80\%).

\textbf{Преимущества TDD в контексте работы.} Подход TDD помог в нескольких аспектах.
Тесты, написанные до основного кода, заставляли заранее продумывать интерфейсы классов и методов, что привело к более чистой архитектуре.
Ошибки обнаруживались сразу при написании кода, а не на этапе ручной проверки.
При рефакторинге (например, при переделке метода \texttt{toString()} или изменении логики валидации) тесты сразу показывали, не сломалось ли что-то.
Тестовые случаи также служили своего рода документацией --- по ним можно понять, как должен работать каждый метод.

\textbf{Недостатки TDD в контексте работы.} Главный минус --- это время.
Написание тестов перед кодом заметно замедляет начальный этап разработки.
Для простых классов-моделей (геттеры, сеттеры, builder) тесты получаются довольно тривиальными и кажутся избыточными.
При изменении требований приходится переписывать не только код, но и тесты, что увеличивает объём работы.
Также оказалось сложно заранее предусмотреть все граничные случаи для алгоритмов на графах --- некоторые тесты пришлось добавлять уже после основной разработки,
по результатам мутационного тестирования.

В целом работа показала, что модульное тестирование --- это полезная практика, которая реально помогает писать более качественный код.
Мутационное тестирование оказалось хорошим дополнением к обычным метрикам покрытия.