\chapter{Методы проектирования тестов} \label{ch2}

Согласно предоставленному в задании списку, для детального изучения были выбраны следующие техники:
\begin{enumerate}
    \item Equivalence Partitioning;
    \item Boundary Value Analysis;
    \item Decision Table Testing;
    \item Branch Testing.
\end{enumerate}


\section{Equivalence Partitioning (Разбиение на классы эквивалентности)}\label{ch2:ep}

Техника Equivalence Partitioning (EP)\cite{iso29119-4} основана на принципе, что входные данные программы могут быть разделены на классы эквивалентности,
все элементы которых предположительно обрабатываются системой одинаковым образом.
Если одно значение из класса приводит к обнаружению дефекта, то ожидается, что и все остальные значения из этого же класса приведут к аналогичному результату, и наоборот.

Процесс применения метода включает следующие шаги:
\begin{enumerate}
    \item \textbf{Идентификация входных и выходных параметров:} Определяются все параметры, которые поступают на вход тестируемой функции или системы, а также ожидаемые выходные данные.
    \item \textbf{Выделение классов эквивалентности:} Для каждого входного параметра выделяются валидные (корректные) и невалидные (некорректные) классы.
    \item Валидные классы описывают данные, которые программа должна обработать корректно.
    \item Невалидные --- данные, для которых программа должна предусматривать обработку ошибок (например, выдавать сообщение об ошибке).
    \item \textbf{Разработка тестов:} Для каждого выделенного класса создаётся как минимум один тестовый случай.
    \item Предпочтительно использовать уникальные значения из середины класса для минимизации риска, что тест будет случайно проверять граничное условие.
\end{enumerate}

Например, для функции, принимающей целое число от 1 до 100, можно выделить три класса эквивалентности: валидный класс (числа от 1 до 100),
невалидный класс «меньше нижней границы» (числа $<1$) и невалидный класс «больше верхней границы» (числа $>100$).
Таким образом, для полного покрытия по критерию EP достаточно трёх тестов: одного с числом из диапазона (например, 50),
одного с числом меньше 1 (например, 0) и одного с числом больше 100 (например, 101).

\section{Boundary Value Analysis (Анализ граничных значений)}\label{ch2:bva}

Техника Boundary Value Analysis (BVA)\cite{iso29119-4} является логическим продолжением и дополнением Equivalence Partitioning.
Она основана на эмпирическом наблюдении, что наибольшая вероятность возникновения ошибок в программе сосредоточена на границах разделения классов эквивалентности.
Эти ошибки часто связаны с некорректным использованием операторов сравнения (например, $>$, $>=$, $<$, $<=$).

Метод BVA предписывает в качестве тестовых данных выбирать не просто произвольные значения из классов, а именно значения на границах этих классов.
Для каждого интервала (класса) тестируются:
\begin{itemize}
    \item Минимальное значение.
    \item Значение, сразу следующее за минимальным (min+1).
    \item Максимальное значение.
    \item Значение, непосредственно предшествующее максимальному (max-1).
\end{itemize}

Например, для того же интервала [1, 100] согласно BVA следует рассмотреть значения: 1, 2, 99, 100.
Для невалидных классов также проверяются граничные значения: 0 (для класса $<1$) и 101 (для класса $>100$).

Комбинация EP и BVA является мощным и эффективным дуэтом для тестирования параметров, принимающих значения из упорядоченных множеств (числа, даты, длины строк и т.д.).

\section{Decision Table Testing (Тестирование на основе таблицы решений)} \label{ch2:dtt}

Метод Decision Table Testing\cite{iso29119-4} применяется для тестирования бизнес-логики, которая может быть описана в виде комбинаций условий и соответствующих им действий.
Этот метод особенно полезен, когда поведение системы зависит от множества логических условий, что приводит к большому количеству возможных сценариев.

Таблица решений состоит из четырёх основных частей:
\begin{enumerate}
    \item \textbf{Условия (Conditions):} Список входных логических условий (вопросов, на которые можно ответить «Да»/«Нет» или «Истина»/«Ложь»).
    \item \textbf{Действия (Actions):} Список возможных выходных действий системы.
    \item \textbf{Столбцы правил (Rules):} Каждый столбец представляет собой уникальную комбинацию значений условий и соответствующий набор выполняемых действий.
    \item \textbf{Значения условий и отметки действий:} В ячейках указываются значения условий (T/F, Y/N) и отмечаются (например, крестиком) действия, которые должны быть выполнены для данного правила.
\end{enumerate}

Процесс создания тестов включает построение таблицы, покрывающей все возможные комбинации условий (полная таблица), или её сокращённой формы,
исключающей невозможные и избыточные комбинации.
Для каждого столбца (правила) в таблице разрабатывается отдельный тестовый сценарий, который задаёт конкретные входные данные,
удовлетворяющие указанной комбинации условий, и проверяет выполнение ожидаемых действий.

Этот метод обеспечивает систематический подход к покрытию сложной логики и помогает выявить пропущенные или некорректные требования.

\section{Branch Testing (Тестирование ветвей)}\label{ch2:bt}

Branch Testing(также известное как тестирование решений)\cite{iso29119-4} --- это метод структурного (или «белого ящика») тестирования.
Его цель --- обеспечить выполнение каждой ветви (каждого исхода каждого логического решения) в программе минимум один раз.
Ветвь соответствует переходу от узла решения (например, оператор `if`, `while`, `for`, `case`) к одному из возможных следующих узлов в графе потока управления программы.

Критерий покрытия ветвей (Branch Coverage) определяется как:
\[
    \text{Покрытие ветвей} = \frac{\text{Количество выполненных ветвей}}{\text{Общее количество ветвей в программе}} \times 100\%
\]

Для достижения 100\% покрытия ветвей необходимо, чтобы каждый возможный исход (например, «истина» и «ложь» для оператора `if`) был выполнен хотя бы один раз в ходе выполнения набора тестов. Этот метод напрямую связан с проверкой полноты тестирования логики принятия решений в коде и является более строгим, чем критерий покрытия операторов, но менее строгим, чем покрытие условий.

На практике Branch Testing помогает выявить ошибки, связанные с недостижимым кодом, неправильными логическими выражениями и пропущенными обработками альтернативных сценариев.

\section{Выводы} \label{ch2:conclusion}

Во второй главе были детально рассмотрены четыре ключевых метода проектирования тестов.
Техники Equivalence Partitioning и Boundary Value Analysis, основанные на анализе входных данных и их границ, образуют набор для эффективного функционального тестирования.
Метод Decision Table Testing предоставляет структурированный инструмент для валидации сложной бизнес-логики, зависящей от множества условий.
Наконец, Branch Testing представляет собой базовый, но мощный структурный критерий, позволяющий оценить и повысить полноту проверки логики программы.
%\FloatBarrier