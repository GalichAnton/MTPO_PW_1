\chapter{Методы проектирования тестов} \label{ch2}

Согласно предоставленному в задании списку, для детального изучения были выбраны следующие техники:
\begin{enumerate}
    \item Equivalence Partitioning;
    \item Boundary Value Analysis;
    \item Decision Table Testing;
    \item Branch Testing.
\end{enumerate}

\section{Техники проектирования тестов на основе спецификаций} \label{ch2:spec_based}

В данном разделе рассматриваются методы, основой для которых служат требования и спецификации
к программному обеспечению, без учёта его внутреннего устройства.
Эти техники, также известные как методы «чёрного ящика»,
направлены на выявление дефектов в функциональности системы~\cite{iso29119-2}.


\subsection{Equivalence Partitioning (Разбиение на классы эквивалентности)}\label{ch2:ep}

Техника Equivalence Partitioning (EP)\cite{kulikov-testing} основана на принципе, что входные данные программы могут быть разделены на классы эквивалентности, все элементы которых предположительно обрабатываются системой одинаковым образом. Если одно значение из класса приводит к обнаружению дефекта, то ожидается, что и все остальные значения из этого же класса приведут к аналогичному результату, и наоборот.

Процесс применения метода включает следующие шаги:
\begin{enumerate}
    \item \textbf{Идентификация входных и выходных параметров:} Определяются все параметры, которые поступают на вход тестируемой функции или системы, а также ожидаемые выходные данные.
    \item \textbf{Выделение классов эквивалентности:} Для каждого входного параметра выделяются валидные (корректные) и невалидные (некорректные) классы. Валидные классы описывают данные, которые программа должна обработать корректно. Невалидные --- данные, для которых программа должна предусматривать обработку ошибок (например, выдавать сообщение об ошибке).
    \item \textbf{Разработка тестов:} Для каждого выделенного класса создаётся как минимум один тестовый случай. Предпочтительно использовать уникальные значения из середины класса для минимизации риска, что тест будет случайно проверять граничное условие.
\end{enumerate}

Например, для функции, принимающей целое число от 1 до 100, можно выделить три класса эквивалентности: валидный класс (числа от 1 до 100), невалидный класс «меньше нижней границы» (числа $<1$) и невалидный класс «больше верхней границы» (числа $>100$). Таким образом, для полного покрытия по критерию EP достаточно трёх тестов: одного с числом из диапазона (например, 50), одного с числом меньше 1 (например, 0) и одного с числом больше 100 (например, 101).

\subsection{Boundary Value Analysis (Анализ граничных значений)}\label{ch2:bva}

Техника Boundary Value Analysis (BVA) является логическим продолжением и дополнением Equivalence Partitioning. Она основана на эмпирическом наблюдении, что наибольшая вероятность возникновения ошибок в программе сосредоточена на границах разделения классов эквивалентности. Эти ошибки часто связаны с некорректным использованием операторов сравнения (например, $>$, $>=$, $<$, $<=$).

Метод BVA предписывает в качестве тестовых данных выбирать не просто произвольные значения из классов, а именно значения на границах этих классов. Для каждого интервала (класса) тестируются:
\begin{itemize}
    \item Минимальное значение.
    \item Значение, сразу следующее за минимальным (min+1).
    \item Максимальное значение.
    \item Значение, непосредственно предшествующее максимальному (max-1).
\end{itemize}

Например, для того же интервала [1, 100] согласно BVA следует рассмотреть значения: 1, 2, 99, 100. Для невалидных классов также проверяются граничные значения: 0 (для класса $<1$) и 101 (для класса $>100$).

Комбинация EP и BVA является мощным и эффективным дуэтом для тестирования параметров, принимающих значения из упорядоченных множеств (числа, даты, длины строк и т.д.).

\section{Логические и структурные техники тестирования} \label{ch2:logic_struct}

Данный раздел посвящён методам, которые требуют анализа логики приложения. Они могут основываться как на спецификации (таблицы решений), так и на структуре исходного кода (тестирование ветвей).

\subsection{Decision Table Testing (Тестирование на основе таблицы решений)}~\cite{iso29119-2} \label{ch2:dtt}

Метод Decision Table Testing применяется для тестирования бизнес-логики, которая может быть описана в виде комбинаций условий и соответствующих им действий. Этот метод особенно полезен, когда поведение системы зависит от множества логических условий, что приводит к большому количеству возможных сценариев.

Таблица решений состоит из четырёх основных частей:
\begin{enumerate}
    \item \textbf{Условия (Conditions):} Список входных логических условий (вопросов, на которые можно ответить «Да»/«Нет» или «Истина»/«Ложь»).
    \item \textbf{Действия (Actions):} Список возможных выходных действий системы.
    \item \textbf{Столбцы правил (Rules):} Каждый столбец представляет собой уникальную комбинацию значений условий и соответствующий набор выполняемых действий.
    \item \textbf{Значения условий и отметки действий:} В ячейках указываются значения условий (T/F, Y/N) и отмечаются (например, крестиком) действия, которые должны быть выполнены для данного правила.
\end{enumerate}

Процесс создания тестов включает построение таблицы, покрывающей все возможные комбинации условий (полная таблица), или её сокращённой формы, исключающей невозможные и избыточные комбинации. Для каждого столбца (правила) в таблице разрабатывается отдельный тестовый сценарий, который задаёт конкретные входные данные, удовлетворяющие указанной комбинации условий, и проверяет выполнение ожидаемых действий.

Этот метод обеспечивает систематический подход к покрытию сложной логики и помогает выявить пропущенные или некорректные требования.

\subsection{Branch Testing (Тестирование ветвей)} \label{ch2:bt}

Branch Testing\cite{kulikov-testing}(также известное как тестирование решений) --- это метод структурного (или «белого ящика») тестирования. Его цель --- обеспечить выполнение каждой ветви (каждого исхода каждого логического решения) в программе минимум один раз.
Ветвь соответствует переходу от узла решения (например, оператор `if`, `while`, `for`, `case`) к одному из возможных следующих узлов в графе потока управления программы.

Критерий покрытия ветвей (Branch Coverage) определяется как:
\[
    \text{Покрытие ветвей} = \frac{\text{Количество выполненных ветвей}}{\text{Общее количество ветвей в программе}} \times 100\%
\]

Для достижения 100\% покрытия ветвей необходимо, чтобы каждый возможный исход (например, «истина» и «ложь» для оператора `if`) был выполнен хотя бы один раз в ходе выполнения набора тестов. Этот метод напрямую связан с проверкой полноты тестирования логики принятия решений в коде и является более строгим, чем критерий покрытия операторов, но менее строгим, чем покрытие условий.

На практике Branch Testing помогает выявить ошибки, связанные с недостижимым кодом, неправильными логическими выражениями и пропущенными обработками альтернативных сценариев.

\section{Выводы} \label{ch2:conclusion}

Во второй главе были детально рассмотрены четыре ключевых метода проектирования тестов. Техники Equivalence Partitioning и Boundary Value Analysis, основанные на анализе входных данных и их границ, образуют фундаментальный набор для эффективного функционального тестирования. Метод Decision Table Testing предоставляет структурированный инструмент для валидации сложной бизнес-логики, зависящей от множества условий. Наконец, Branch Testing представляет собой базовый, но мощный структурный критерий, позволяющий оценить и повысить полноту проверки логики программы.

Выбор именно этого набора методов обусловлен их широкой применимостью, взаимодополняемостью и возможностью комбинации для создания всесторонних тестовых наборов. Equivalence Partitioning и Boundary Value Analysis позволяют систематически выбирать тестовые данные. Decision Table Testing обеспечивает покрытие логических связей между ними. Branch Testing же служит объективной метрикой для оценки того, насколько полно тесты проверяют внутреннюю структуру кода. В совокупности эти методы позволяют подойти к процессу тестирования как с позиции внешних требований, так и с точки зрения внутренней реализации, что способствует повышению качества программного обеспечения.

%\FloatBarrier