\chapter{Мутационное тестирование} \label{ch7}

В данной главе представлены результаты мутационного тестирования, проведённого с использованием инструмента PIT (Pitest)\cite{parkhomenko-lectures} версии 1.15.8.


\section{Мутационные операторы} \label{ch7:operators}

При проведении мутационного тестирования использовалась конфигурация \texttt{DEFAULTS} инструмента Pitest,
которая включает набор стандартных мутационных операторов.
В таблице~\ref{tab:mutation_operators} представлен полный перечень задействованных операторов.

\begin{table}[htbp]
    \centering
    \caption{Мутационные операторы группы DEFAULTS в Pitest}
    \label{tab:mutation_operators}
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Оператор} & \textbf{Описание} \\
        \hline
        CONDITIONALS\_BOUNDARY & Заменяет граничные условия: \texttt{<} на \texttt{<=}, \texttt{>} на \texttt{>=} и наоборот \\
        \hline
        INCREMENTS & Заменяет инкременты на декременты: \texttt{++} на \texttt{--} и наоборот \\
        \hline
        INVERT\_NEGS & Инвертирует знак отрицания числовых значений \\
        \hline
        MATH & Заменяет математические операции: \texttt{+} на \texttt{-}, \texttt{*} на \texttt{/}, \texttt{\%} на \texttt{*} и т.д. \\
        \hline
        NEGATE\_CONDITIONALS & Инвертирует условные выражения: \texttt{==} на \texttt{!=}, \texttt{<} на \texttt{>=} \\
        \hline
        VOID\_METHOD\_CALLS & Удаляет вызовы void-методов \\
        \hline
        EMPTY\_RETURNS & Заменяет возвращаемые значения на пустые: \texttt{null}, пустую коллекцию, 0 \\
        \hline
        FALSE\_RETURNS & Заменяет возвращаемые boolean-значения на \texttt{false} \\
        \hline
        TRUE\_RETURNS & Заменяет возвращаемые boolean-значения на \texttt{true} \\
        \hline
        NULL\_RETURNS & Заменяет возвращаемые объекты на \texttt{null} \\
        \hline
        PRIMITIVE\_RETURNS & Заменяет возвращаемые примитивы на 0 \\
        \hline
    \end{tabular}
\end{table}

\subsection*{Применение операторов к исходному коду}

В таблице~\ref{tab:operator_examples} приведены примеры применения мутационных операторов к коду проекта топологической сортировки.

\begin{table}[htbp]
    \centering
    \caption{Примеры применения мутационных операторов}
    \label{tab:operator_examples}
    \small
    \begin{tabular}{|l|p{4.5cm}|p{4.5cm}|}
        \hline
        \textbf{Оператор} & \textbf{Исходный код} & \textbf{Мутированный код} \\
        \hline
        CONDITIONALS\_BOUNDARY & \texttt{if (edge.size() != 2)} & \texttt{if (edge.size() < 2)} \\
        \hline
        NEGATE\_CONDITIONALS & \texttt{if (graph.isEmpty())} & \texttt{if (!graph.isEmpty())} \\
        \hline
        VOID\_METHOD\_CALLS & \texttt{color.put(vertex, GRAY)} & удалён вызов метода \\
        \hline
        EMPTY\_RETURNS & \texttt{return result;} & \texttt{return Collections.emptyList();} \\
        \hline
        TRUE\_RETURNS & \texttt{return vertices.contains(v)} & \texttt{return true;} \\
        \hline
    \end{tabular}
\end{table}

\section{Эквивалентные мутации} \label{ch7:equivalent}

\subsection*{Определение эквивалентных мутаций}

\textbf{Эквивалентная мутация} --- это мутация исходного кода, которая не изменяет наблюдаемое поведение программы ни при каких входных данных.
Такая мутация семантически эквивалентна исходному коду и принципиально не может быть обнаружена (``убита'') никаким тестом.

Эквивалентные мутации представляют фундаментальную проблему мутационного тестирования, так как:
\begin{itemize}
    \item невозможно автоматически определить, является ли мутация эквивалентной;
    \item выжившие эквивалентные мутации искусственно занижают показатель mutation score;
    \item требуется ручной анализ для классификации выживших мутаций.
\end{itemize}

\subsection*{Типичные случаи эквивалентных мутаций}

В таблице~\ref{tab:equivalent_examples} представлены типичные паттерны эквивалентных мутаций.

\begin{table}[htbp]
    \centering
    \caption{Примеры эквивалентных мутаций}
    \label{tab:equivalent_examples}
    \begin{tabular}{|p{5cm}|p{7cm}|}
        \hline
        \textbf{Тип} & \textbf{Пример} \\
        \hline
        Избыточное условие & Замена \texttt{i >= 0} на \texttt{i > -1} в цикле, где \texttt{i} всегда неотрицательно \\
        \hline
        Недостижимая ветвь & Мутация кода в ветви, которая никогда не выполняется \\
        \hline
        Семантическая эквивалентность & Замена \texttt{x * 2} на \texttt{x + x} \\
        \hline
        Неиспользуемый результат & Мутация в методе, результат которого игнорируется \\
        \hline
    \end{tabular}
\end{table}

\textbf{Пример эквивалентной мутации:}

\begin{verbatim}
// Исходный код метода toString()
if (!neighbors.isEmpty()) {
    sb.append("    ").append(vertex)
      .append(" -> ").append(neighbors).append("\n");
}

// Мутация: NEGATE_CONDITIONALS
if (neighbors.isEmpty()) {  // инвертировано условие
    sb.append("    ").append(vertex)
      .append(" -> ").append(neighbors).append("\n");
}
\end{verbatim}

Данная мутация в методе \texttt{toString()} класса \texttt{Graph} может быть классифицирована как \textbf{эквивалентная} по следующим причинам:
\begin{enumerate}
    \item Метод \texttt{toString()} используется преимущественно для отладки и логирования;
    \item Существующие тесты не проверяют строковое представление графов с пустыми списками соседей;
    \item Изменение формата вывода не влияет на функциональную корректность алгоритмов сортировки.
\end{enumerate}

Однако данная мутация не является полностью эквивалентной, так как изменяет результат метода \texttt{toString()} для определённых входных данных.
Она относится к категории \textbf{выживших мутаций}, которые могут быть убиты дополнительными тестами.

\section{Метрики качества тестов} \label{ch7:metrics}

\subsection*{Результаты мутационного тестирования}

По результатам запуска Pitest (рисунок~\ref{fig:pit_before}) получены следующие показатели:
\begin{itemize}
    \item Количество тестируемых классов: 3 (пакет \texttt{model})
    \item Всего сгенерировано мутаций: 88
    \item Убито мутаций: 72
    \item Выжило мутаций: 16
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{../my_folder/images/from.png}
    \caption{Отчёт Pitest}
    \label{fig:pit_before}
\end{figure}

\subsection*{Определение метрик}

В таблице~\ref{tab:metrics_definition} представлены основные метрики мутационного тестирования и их определения.

\begin{table}[htbp]
    \centering
    \caption{Метрики мутационного тестирования}
    \label{tab:metrics_definition}
    \begin{tabular}{|l|l|p{6cm}|}
        \hline
        \textbf{Метрика} & \textbf{Формула} & \textbf{Описание} \\
        \hline
        LCC (Line Code Coverage) & $\frac{\text{Покрытые строки}}{\text{Всего строк}}$ & Процент строк кода, выполненных хотя бы одним тестом \\
        \hline
        MSI (Mutation Score Indicator) & $\frac{\text{Убитые мутации}}{\text{Всего мутаций}}$ & Основной показатель качества тестов относительно мутаций \\
        \hline
        MCC (Mutation Code Coverage) & $\frac{\text{Покрытые мутации}}{\text{Всего мутаций}}$ & Процент мутаций, покрытых тестами \\
        \hline
        CoveredCodeMSI & $\frac{\text{Убитые мутации}}{\text{Покрытые мутации}}$ & MSI только для покрытого кода (Test Strength) \\
        \hline
    \end{tabular}
\end{table}

В таблице~\ref{tab:metrics_values} представлены значения метрик для разработанных модульных тестов.

\begin{table}[htbp]
    \centering
    \caption{Значения метрик мутационного тестирования}
    \label{tab:metrics_values}
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Метрика} & \textbf{Значение} & \textbf{Расчёт} \\
        \hline
        LCC (Line Coverage) & 99\% & 163 / 164 строк \\
        \hline
        MSI (Mutation Score) & 82\% & 72 / 88 мутаций \\
        \hline
        MCC (Mutation Coverage) & 100\% & Все мутации покрыты тестами \\
        \hline
        CoveredCodeMSI (Test Strength) & 82\% & 72 / 88 (совпадает с MSI) \\
        \hline
    \end{tabular}
\end{table}

\section{Анализ mutation-adequacy} \label{ch7:adequacy}

\subsection*{Критерий mutation-adequate}

Набор тестов считается \textbf{mutation-adequate}, если он убивает все неэквивалентные мутации, то есть достигает 100\% mutation score (исключая эквивалентные мутации).

\subsection*{Оценка разработанных тестов}

Анализ результатов позволяет сделать следующие выводы:

\begin{enumerate}
    \item \textbf{Формально тесты не являются mutation-adequate}, так как MSI составляет 82\%, а не 100\%.

    \item \textbf{Количество выживших мутаций}: 16 мутаций из 88 не были обнаружены тестами.

    \item \textbf{Причины выживания мутаций} (по результатам детального анализа):
    \begin{itemize}
        \item Мутации в методе \texttt{toString()} класса \texttt{ComparisonResult} --- 7 мутаций (замена условий в тернарных операторах и ветвлениях);
        \item Мутации \texttt{TRUE\_RETURNS} в boolean-геттерах класса \texttt{ComparisonResult} --- 3 мутации;
        \item Мутации в методе \texttt{addEdge()} класса \texttt{Graph} --- 3 мутации (удаление валидации и условий);
        \item Мутации в методах \texttt{containsVertex()} и \texttt{toString()} класса \texttt{Graph} --- 2 мутации;
        \item Мутация \texttt{hashCode()} класса \texttt{SortResult} --- 1 мутация.
    \end{itemize}
\end{enumerate}

Хотя разработанные тесты формально не достигают критерия mutation-adequate, они демонстрируют высокое качество по следующим причинам:
\begin{itemize}
    \item MSI превышает минимально допустимый порог (80\%);
    \item Большинство выживших мутаций относится к вспомогательным методам (\texttt{toString}, boolean-геттеры), а не к основной бизнес-логике;
    \item Критически важные алгоритмы топологической сортировки (DFS и Kahn) имеют более высокий локальный mutation score.
\end{itemize}

\section{Улучшение качества тестов} \label{ch7:improvement}

\subsection*{Анализ выживших мутаций}

Для улучшения качества тестов был проведён анализ выживших мутаций на основе отчётов PIT и разработаны дополнительные тесты.

Ниже приведены примеры тестов.

\textbf{Тест 1: Проверка boolean-геттеров с false-значениями}

Файл: \texttt{ResultsTest.java}, класс \texttt{ComparisonResultTests}.

\begin{verbatim}
@Test
@DisplayName("Boolean-геттеры возвращают false")
void testBooleanGetters_ReturnFalse() {
    ComparisonResult comparison = ComparisonResult.builder()
            .dfsResult(SortResult.success(
                List.of("A"), "DFS", 1.0))
            .kahnResult(SortResult.success(
                List.of("A"), "Kahn", 1.0))
            .vertexCount(1).edgeCount(0)
            .dfsValid(false)
            .kahnValid(false)
            .identicalOrder(false)
            .recommendation("").build();

    assertFalse(comparison.isDfsValid());
    assertFalse(comparison.isKahnValid());
    assertFalse(comparison.isIdenticalOrder());
}
\end{verbatim}

\textbf{Тест 2: Валидация вершин в addEdge()}

Файл: \texttt{GraphTest.java}.

\begin{verbatim}
@Test
@DisplayName("addEdge выбрасывает исключение для null/пустых вершин")
void testAddEdge_InvalidVertexValidation() {
    graph.addVertex("A");
    graph.addVertex("B");

    assertThrows(IllegalArgumentException.class,
            () -> graph.addEdge(null, "B"));
    assertThrows(IllegalArgumentException.class,
            () -> graph.addEdge("A", null));
    assertThrows(IllegalArgumentException.class,
            () -> graph.addEdge("", "B"));
    assertThrows(IllegalArgumentException.class,
            () -> graph.addEdge("A", "  "));
}
\end{verbatim}

\textbf{Тест 3: toString() с точной проверкой условных ветвей}

Файл: \texttt{ResultsTest.java}, класс \texttt{ComparisonResultTests}.

\begin{verbatim}
@Test
@DisplayName("toString корректно отражает все условные ветви")
void testToString_ConditionalBranches() {
    // Случай 1: успех + валидный + идентичный порядок
    ComparisonResult success = ComparisonResult.builder()
            .dfsResult(SortResult.success(
                List.of("A"), "DFS", 1.0))
            .kahnResult(SortResult.success(
                List.of("A"), "Kahn", 1.0))
            .vertexCount(1).edgeCount(0)
            .dfsValid(true).kahnValid(true)
            .identicalOrder(true)
            .recommendation("").build();
    String sStr = success.toString();
    assertThat(sStr, allOf(
        containsString("\u2713 Успех"),
        containsString("\u2713 Валидный порядок"),
        containsString("Да")
    ));

    // Случай 2: ошибка + невалидный + разный порядок
    ComparisonResult failure = ComparisonResult.builder()
            .dfsResult(SortResult.failure("Err", "DFS", 1.0))
            .kahnResult(SortResult.failure("Err", "Kahn", 1.0))
            .vertexCount(1).edgeCount(0)
            .dfsValid(false).kahnValid(false)
            .identicalOrder(false)
            .recommendation("").build();
    String fStr = failure.toString();
    assertThat(fStr, allOf(
        containsString("\u2717 Ошибка"),
        containsString("\u2717 Невалидный"),
        containsString("Нет")
    ));
}
\end{verbatim}

\textbf{Тест 4: containsVertex() для несуществующей вершины}

Файл: \texttt{GraphTest.java}.

\begin{verbatim}
@Test
@DisplayName("containsVertex возвращает false для отсутствующей вершины")
void testContainsVertex_NotExists() {
    graph.addVertex("A");

    assertFalse(graph.containsVertex("Z"));
    assertFalse(graph.containsVertex("nonexistent"));
}
\end{verbatim}

\textbf{Тест 5: hashCode() чувствительность к данным}

Файл: \texttt{ResultsTest.java}, класс \texttt{SortResultTests}.

\begin{verbatim}
@Test
@DisplayName("hashCode различен для разных результатов")
void testHashCode_Different() {
    SortResult r1 = SortResult.success(
            List.of("A", "B"), "DFS", 1.0);
    SortResult r2 = SortResult.success(
            List.of("B", "A"), "DFS", 1.0);

    assertNotEquals(r1.hashCode(), r2.hashCode());
}
\end{verbatim}

\textbf{Тест 6: toString() Graph с рёбрами}

Файл: \texttt{GraphTest.java}.

\begin{verbatim}
@Test
@DisplayName("toString содержит информацию о рёбрах графа")
void testToString_ContainsEdgeInfo() {
    graph.addVertex("A");
    graph.addVertex("B");
    graph.addEdge("A", "B");

    String result = graph.toString();
    assertThat(result, containsString("A -> [B]"));
}
\end{verbatim}

\subsection*{Результаты улучшения}

После добавления тестов был выполнен повторный запуск PIT (рисунок~\ref{fig:pit_after}).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{../my_folder/images/to.png}
    \caption{Отчёт Pitest после улучшения тестов}
    \label{fig:pit_after}
\end{figure}

В таблице~\ref{tab:improvement_results} представлено сравнение метрик до и после добавления тестов.

\begin{table}[htbp]
    \centering
    \caption{Результаты улучшения тестового покрытия}
    \label{tab:improvement_results}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Метрика} & \textbf{До} & \textbf{После} & \textbf{Изменение} \\
        \hline
        Line Coverage & 99\% (163/164) & 99\% (163/164) & -- \\
        \hline
        Mutation Score & 82\% (72/88) & 90\% (79/88) & +8\% \\
        \hline
        Убито мутаций & 72 & 79 & +7 \\
        \hline
        Выжило мутаций & 16 & 9 & $-7$ \\
        \hline
    \end{tabular}
\end{table}

Добавленные тесты убили 7 из 16 выживших мутаций

\subsection*{Выводы}

Мутационное тестирование с помощью Pitest позволило:
\begin{enumerate}
    \item Найти слабые места в тестах, которые не видны по обычным метрикам --- при покрытии строк 99\% mutation score был 82\%;
    \item Понять, какие тесты нужно добавить в первую очередь: проверки boolean-геттеров с значением \texttt{false}, тест \texttt{containsVertex()} для несуществующей вершины, проверка \texttt{hashCode()};
    \item Поднять mutation score с 82\% до 90\% за счёт 6 дополнительных тестов, которые убили 7 мутаций;
    \item Убедиться, что оставшиеся 9 выживших мутаций находятся в методах форматирования вывода (\texttt{toString}) и дублирующей валидации (\texttt{addEdge}), и не влияют на работу основных алгоритмов сортировки.
\end{enumerate}

Итоговый MSI = 90\% превышает типичные промышленные пороги (60--80\%), что говорит о хорошем качестве написанных тестов.
Мутационное тестирование показало, что покрытие строк кода и mutation score --- это разные вещи, и высокий процент покрытия ещё не означает, что тесты действительно хорошо проверяют код.
Анализ выживших мутаций помог точечно улучшить тестовый набор.
